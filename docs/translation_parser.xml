<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>The Translation Parser</title>

  <para>SWeTE does a pretty good job of parsing HTML content and extracting a
  set of phrases to be translated. In cases where the HTML markup doesn't make
  structure explicit, you can add your own HTML tags and attributes to the
  content to help it along.</para>

  <section>
    <title>How the Translation Parser Works</title>

    <para>A request-response cycle in SWeTE works roughly as follows:</para>

    <para/>

    <orderedlist>
      <listitem>
        <para>Client makes an HTTP request for a page in the SWeTE proxy
        site.</para>
      </listitem>

      <listitem>
        <para>SWeTE loads the equivalent page from the source web server (or
        from the cache if the page is cached).</para>
      </listitem>

      <listitem>
        <para>SWeTE parses the source HTML page into a set of strings.</para>
      </listitem>

      <listitem>
        <para>For each string in the set of strings (from step 3), SWeTE
        checks the translation memory to see if there is a translation
        available for it.</para>
      </listitem>

      <listitem>
        <para>SWeTE replaces all strings in the HTML page with their
        appropriate translations if available.</para>
      </listitem>

      <listitem>
        <para>SWeTE returns the resulting (translated) page to the
        client.</para>
      </listitem>
    </orderedlist>

    <para>This chapter will focus mostly on step 3 (parsing a webpage into
    strings). It is possible to use SWeTE successfully without understanding
    much about how the parsing works, but you can achieve much better results
    if you know how it works, and thus, know how to manipulate it.</para>

    <para/>
  </section>

  <section>
    <title>Block Level Elements vs Inline Elements</title>

    <para>SWeTE's parsing algorithm is designed to figure out how the text of
    a page should be partitioned into strings. By default, SWeTE will look for
    what it considers to be "block-level" HTML elements. It treats the text
    content of each "block-level" as an atomic string (phrase) for use in
    translation. Block-level elements include such elements as:</para>

    <para/>

    <itemizedlist>
      <listitem>
        <para><literal>&lt;p&gt;</literal> tags (paragraphs)</para>
      </listitem>

      <listitem>
        <para><literal>&lt;div&gt;</literal> tags</para>
      </listitem>

      <listitem>
        <para><literal>&lt;li&gt;</literal> tags</para>
      </listitem>

      <listitem>
        <para><literal>&lt;h1&gt;</literal>, <literal>&lt;h2&gt;</literal>,
        <literal>&lt;h3&gt;</literal>, etc... tags (i.e. headings)</para>
      </listitem>
    </itemizedlist>

    <para>In fact, SWeTE considers any tag that is not an "inline" tag to be a
    "block-level" tag. The definitive set of "inline" tags are:</para>

    <para><literal>&lt;a&gt;, &lt;em&gt;, &lt;abbr&gt;, &lt;i&gt;, &lt;u&gt;,
    &lt;b&gt;, &lt;span&gt;, &lt;strong&gt;, &lt;acronym&gt;, &lt;font&gt;,
    &lt;sup&gt;, &lt;sub&gt;</literal></para>

    <para>In addition, you can also explicitly specify that a tag should be
    treated as "inline" by adding the <literal>data-swete-inline="1"</literal>
    HTML attribute to it.</para>

    <para><literal/></para>

    <formalpara>
      <title>Example Parse Tree</title>

      <para>Consider the following snippet of HTML:</para>
    </formalpara>

    <programlisting>&lt;p&gt;&lt;a href="http://google.com"&gt;Google&lt;/a&gt; is one of the most &lt;em&gt;AMAZING&lt;/em&gt; search engines.&lt;/p&gt;
&lt;p&gt;It returned the following results:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Dogs&lt;/li&gt;
    &lt;li&gt;Cats&lt;/li&gt;
    &lt;li&gt;Butterflies&lt;/li&gt;
&lt;/ul&gt;</programlisting>

    <para>This would be parsed into the following strings:</para>

    <para/>

    <itemizedlist>
      <listitem>
        <para>&lt;a href="http://google.com"&gt;Google&lt;/a&gt; is one of the
        most &lt;em&gt;AMAZING&lt;/em&gt; search engines.</para>
      </listitem>

      <listitem>
        <para>It returned the following results:</para>
      </listitem>

      <listitem>
        <para>Dogs</para>
      </listitem>

      <listitem>
        <para>Cats</para>
      </listitem>

      <listitem>
        <para>Butterflies</para>
      </listitem>
    </itemizedlist>

    <para>This break-down seems to follow the semantic flow of the text quite
    well. It keeps sentences together, and groups "inline" tags into a single
    string (e.g. The <literal>&lt;a&gt; </literal>and
    <literal>&lt;em&gt;</literal> tags in the first paragraph are just
    included inside the parent string rather than being partitioned into their
    own strings). This is largely because the HTML mark up is clean and
    following the semantics of the content. Well-written HTML should maintain
    this characteristic, but you may find exceptions where the HTML markup
    does not break-down well semantically.</para>

    <para>One common HTML construct that doesn't fare well under the default
    rules are menus of <literal>&lt;a&gt;</literal> tags. E.g., consider the
    following HTML menu:</para>

    <programlisting>&lt;div id="menu"&gt;
    &lt;a href="home.html"&gt;Home&lt;/a&gt; | 
    &lt;a href="about.html"&gt;About&lt;/a&gt; |
    &lt;a href="contact.html"&gt;Contact&lt;/a&gt;
&lt;/div&gt;</programlisting>

    <para>Because <literal>&lt;a&gt;</literal> tags are inline elements, SWeTE
    will parse this into a single string for translation. Semantically,
    though, each of the <literal>&lt;a&gt;</literal> tags should be treated as
    separate.</para>

    <note>
      <para>Why does it matter whether a string is extracted out into its
      component parts or extracted as one big string? In both cases, they can
      be translated using SWeTE and it will work properly. The advantage of
      breaking it down into smaller pieces is that these pieces can be reused
      more easily. In the example menu above, if we translate the full menu as
      a single string then the translation can only be used to translate menus
      that are identical (i.e. same menu items and order exactly). However, if
      we were to extract the individual menu items ("Home", "About", and
      "Contact") separately, then these translations could be used any any
      other menus containing the same labels, even if the menu as a whole is
      different.</para>
    </note>

    <para>The difference is apparent when you place this menu into a larger
    context. For example, consider the following page that includes menus at
    the head and foot that are almost the same but have a slightly different
    order:</para>

    <programlisting>&lt;div id="menu1"&gt;
    &lt;a href="home.html"&gt;Home&lt;/a&gt; | 
    &lt;a href="about.html"&gt;About&lt;/a&gt; |
    &lt;a href="contact.html"&gt;Contact&lt;/a&gt;
&lt;/div&gt;
&lt;div id="content"&gt;
    &lt;p&gt;This is some page content.  Ain't it great!&lt;/p&gt;
&lt;/div&gt;
&lt;div id="menu2"&gt;
    &lt;a href="home.html"&gt;Home&lt;/a&gt; | 
    &lt;a href="example.html"&gt;Examples&lt;/a&gt; |
    &lt;a href="about.html"&gt;About&lt;/a&gt; |
    &lt;a href="contact.html"&gt;Contact&lt;/a&gt;
&lt;/div&gt;</programlisting>

    <para>When SWeTE parses this, it will produce three strings:</para>

    <itemizedlist>
      <listitem>
        <para>&lt;a href="home.html"&gt;Home&lt;/a&gt; | &lt;a
        href="about.html"&gt;About&lt;/a&gt; | &lt;a
        href="contact.html"&gt;Contact&lt;/a&gt;</para>
      </listitem>

      <listitem>
        <para>This is some page content. Ain't it great!</para>
      </listitem>

      <listitem>
        <para>&lt;a href="home.html"&gt;Home&lt;/a&gt; | &lt;a
        href="example.html"&gt;Examples&lt;/a&gt; | &lt;a
        href="about.html"&gt;About&lt;/a&gt; | &lt;a
        href="contact.html"&gt;Contact&lt;/a&gt;</para>
      </listitem>
    </itemizedlist>

    <para>Notice that it extracts the menus as being distinct strings even
    though their content is largely the same. It would be much better if it
    just extracted the individual menu labels separately. In fact, this is how
    it would work if <literal>&lt;a&gt;</literal> tags were block-level. But
    SWeTE has no way of knowing that we intend for *these* particular tags to
    be block level, since, most of the time, <literal>&lt;a&gt;</literal> tags
    are just included in other content without disrupting the flow. Unless,
    that is, you give SWeTE a hint.</para>

    <section>
      <title>Explicitly Declaring a tag block-level (the
      <literal>data-swete-block</literal> attribute)</title>

      <para>In cases, like the one above, you can specify that a tag should be
      treated as a block-level tag by adding the data-swete-block attribute to
      the tag. E.g. Consider our previous example with a header and footer
      menu but with the minor adjustment of adding the
      <literal>data-swete-block</literal> attribute to the
      <literal>&lt;a&gt;</literal> tags:</para>

      <programlisting>&lt;div id="menu1"&gt;
    &lt;a href="home.html" data-swete-block="1"&gt;Home&lt;/a&gt; | 
    &lt;a href="about.html" data-swete-block="1"&gt;About&lt;/a&gt; |
    &lt;a href="contact.html" data-swete-block="1"&gt;Contact&lt;/a&gt;
&lt;/div&gt;
&lt;div id="content"&gt;
    &lt;p&gt;This is some page content.  Ain't it great!&lt;/p&gt;
&lt;/div&gt;
&lt;div id="menu2"&gt;
    &lt;a href="home.html" data-swete-block="1"&gt;Home&lt;/a&gt; | 
    &lt;a href="example.html" data-swete-block="1"&gt;Examples&lt;/a&gt; |
    &lt;a href="about.html" data-swete-block="1"&gt;About&lt;/a&gt; |
    &lt;a href="contact.html" data-swete-block="1"&gt;Contact&lt;/a&gt;
&lt;/div&gt;</programlisting>

      <para>Now, SWeTE will parse this to the following strings for
      translation:</para>

      <itemizedlist>
        <listitem>
          <para>Home</para>
        </listitem>

        <listitem>
          <para>About</para>
        </listitem>

        <listitem>
          <para>Contact</para>
        </listitem>

        <listitem>
          <para>This is some page content. Ain't it great!</para>
        </listitem>

        <listitem>
          <para>Examples</para>
        </listitem>
      </itemizedlist>

      <para>Much cleaner and easier to manage. Not only does this produce less
      translation work right now, it will reduce work later if the menus are
      modified further. With the previous structure (where the menus are
      extracted into a single string), any modification to the menu (i.e.
      changing order, adding/removing menu items, etc..) would result in
      having to retranslate the entire menu. Under this new structure, you
      would only need to translate those menu items that are added.</para>

      <tip>
        <para>If you want to build HTML menus, it is best practice to use
        <literal>&lt;ul&gt;</literal> or <literal>&lt;ol&gt;</literal> tags
        with <literal>&lt;li&gt;</literal> children rather than just using
        bare <literal>&lt;a&gt;</literal> tags. This preserves the semantic
        intent of the menus and will be more compatible across devices. If you
        were to use this strategy then you wouldn't need to provide any
        special instructions for SWeTE. It would interpret each menu item as
        its own string by default. The HTML for this structure would look
        like:</para>

        <programlisting>&lt;div id="menu1"&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href="home.html"&gt;Home&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="about.html"&gt;About&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="contact.html"&gt;Contact&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;

&lt;/div&gt;
&lt;div id="content"&gt;
    &lt;p&gt;This is some page content.  Ain't it great!&lt;/p&gt;
&lt;/div&gt;
&lt;div id="menu2"&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href="home.html"&gt;Home&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="example.html"&gt;Examples&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="about.html"&gt;About&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="contact.html"&gt;Contact&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;</programlisting>

        <para>While default browser styles would lay these
        <literal>&lt;ul&gt;</literal> tags (unordered lists) as lists rather
        than horizontal menus, it is a simple matter to customize their layout
        using CSS to match the look of the previous menus with simple inline
        <literal>&lt;a&gt;</literal> tags.</para>
      </tip>
    </section>

    <section>
      <title>Explicitly declaring tags "inline": the
      <literal>data-swete-inline</literal> attribute</title>

      <para>There may also be cases when a tag is being treated as a
      "block-level" tag but you want it to be treated as an inline tag. Use
      the <literal>data-swete-inline</literal> attribute for this. For
      example, consider the following snippet:</para>

      <programlisting>&lt;p&gt;My phone number is &lt;customtag phone="work"&gt;555-222-333&lt;/customtag&gt; but you should email me.&lt;/p&gt;</programlisting>

      <para>Since this uses a custom tag
      (<literal>&lt;customtag&gt;</literal>), SWeTE will interpret it as
      block-level, and will parse it into the following strings:</para>

      <itemizedlist>
        <listitem>
          <para>My phone number is</para>
        </listitem>

        <listitem>
          <para>555-222-3333</para>
        </listitem>

        <listitem>
          <para>but you should email me.</para>
        </listitem>
      </itemizedlist>

      <para>Clearly, the <literal>&lt;customtag&gt;</literal> is meant to be
      interpreted as an inline tag here, but SWeTE is interpreting it as a
      block-level tag (which is the default). We can rectify this by adding
      the <literal>data-swete-inline</literal> attribute:</para>

      <programlisting>&lt;p&gt;My phone number is &lt;customtag phone="work" data-swete-inline="1"&gt;555-222-333&lt;/customtag&gt; but you should email me.&lt;/p&gt;</programlisting>

      <para>Then it will all be extracted into a single string:</para>

      <itemizedlist>
        <listitem>
          <para>My phone number is &lt;customtag phone="work"
          data-swete-inline="1"&gt;555-222-333&lt;/customtag&gt; but you
          should email me.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Overriding the Parser: <literal>translate</literal> &amp;
    <literal>notranslate</literal></title>

    <para>In some cases you may want to be very explicit about what gets
    translated and how a document is partitioned into strings. SWeTE supports
    the <literal>translate</literal> and <literal>notranslate</literal> HTML
    attributes for this purpose. <literal>notranslate</literal> tells SWeTE
    not to parse anything inside of its tag. <literal>translate</literal>
    specifies that the contents of the tag should be treated as a single
    string, even if it contains sub elements. Using these attributes in tandem
    provides an alternative to the SWeTE parser. Indeed, in some cases you may
    want to mark the <literal>&lt;body&gt;</literal> tag with notranslate and
    then just explicitly mark the sections that you with to translate within
    the body.</para>

    <para>For example, consider the menu with inline
    <literal>&lt;a&gt;</literal> tags from the previous section:</para>

    <programlisting>&lt;div id="menu"&gt;
    &lt;a href="home.html"&gt;Home&lt;/a&gt; | 
    &lt;a href="about.html"&gt;About&lt;/a&gt; |
    &lt;a href="contact.html"&gt;Contact&lt;/a&gt;
&lt;/div&gt;</programlisting>

    <para>As we saw before, SWeTE will parse all menu items into a single
    string, which is not optimal. Previously we saw a solution to this problem
    involving the <literal>data-swete-block</literal> attribute. You could,
    alternatively solve this problem using a combination of the translate and
    notranslate attributes as follows:</para>

    <programlisting>&lt;div id="menu" notranslate="1"&gt;
    &lt;a href="home.html" translate="1"&gt;Home&lt;/a&gt; | 
    &lt;a href="about.html" translate="1"&gt;About&lt;/a&gt; |
    &lt;a href="contact.html" translate="1"&gt;Contact&lt;/a&gt;
&lt;/div&gt;</programlisting>

    <para>This instructs SWeTE to "not translate" anything inside the "menu"
    div. It then further instructs SWeTE to translate the specific individual
    <literal>&lt;a&gt;</literal> tag contents. SWeTE will parse this into the
    following strings:</para>

    <itemizedlist>
      <listitem>
        <para>Home</para>
      </listitem>

      <listitem>
        <para>About</para>
      </listitem>

      <listitem>
        <para>Contact</para>
      </listitem>
    </itemizedlist>

    <para><note>
        <para>The translate and notranslate attributes should not be confused
        with the data-swete-translate attribute. Both translate and
        notranslate will cause their tag to be treated as block-level. You
        should not use notranslate in an inline tag, or you'll experience
        unintended results. You should use the data-swete-translate="0"
        attribute for inline content that you want to exempt from
        translation.</para>
      </note></para>
  </section>

  <section>
    <title>String Equivalence</title>

    <para>After SWeTE parses the strings out of an HTML page, it checks the
    translation memory for the site to see if there are any translations for
    the extracted strings. It will only use a translation if the string is an
    exact match. However it does have a hashing algorithm for string
    equivalence that factors out HTML tags, and variables (inline sections
    that should either be translated or not depending on the type of
    variable). This allows for maximum translation reuse without the
    possibility for incorrect translations bleeding into the output.</para>

    <para>According to SWeTE's hashing algorithm, the following strings are
    equivalent:</para>

    <itemizedlist>
      <listitem>
        <para>Hello my name is &lt;a
        href="mailto:steve@example.com"&gt;Steve&lt;/a&gt;.</para>
      </listitem>

      <listitem>
        <para>Hello my name is &lt;span
        style="color:blue"&gt;Steve&lt;/span&gt;.</para>
      </listitem>

      <listitem>
        <para>Hello my name is &lt;x&gt;Steve&lt;/x&gt;.</para>
      </listitem>
    </itemizedlist>

    <para>But these are not the same as:</para>

    <itemizedlist>
      <listitem>
        <para>Hello my name is Steve.</para>
      </listitem>

      <listitem>
        <para>Hello my name is &lt;span&gt;Steve&lt;/span&gt;</para>
      </listitem>

      <listitem>
        <para>hello my name is &lt;span&gt;Steve&lt;/span&gt;.</para>
      </listitem>

      <listitem>
        <para>Hello my name &lt;span&gt;is Steve&lt;/span&gt;.</para>
      </listitem>
    </itemizedlist>

    <para>The reason why these last 3 are not equivalent to the first three or
    to each other is that they are missing key elements. The first one is
    missing the HTML tag, so it will be recognized as a distinct string. The
    second one is missing the trailing punctuation point. And the third one
    has a lower case "h" in "hello" rather than the upper case version in the
    previous three. And the last one has the span tag around "is Steve"
    instead of just "Steve".</para>

    <para>This example shows the following rules of string equivalence:</para>

    <orderedlist>
      <listitem>
        <para>Punctuation matters</para>
      </listitem>

      <listitem>
        <para>Strings are case-sensitive</para>
      </listitem>

      <listitem>
        <para>Different HTML tags with the same placement have no effect
        string equivalence. I.e. It doesn't matter what the tag is or what
        attributes are in the tag. All that matters is where the tag is
        located within the String.</para>
      </listitem>
    </orderedlist>

    <example>
      <title>A page with only one unique sting</title>

      <para>The following page has 3 strings, but since they are all
      equivalent unders SWeTE's string equivalence rules, it will only store
      the first one in the translation memory.</para>

      <programlisting>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;body&gt;

        &lt;ul&gt;
            &lt;li&gt;Hello my name is &lt;span&gt;Steve&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;Hello my name is &lt;a href="home.html"&gt;Steve&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;Hello my name is &lt;name data-swete-inline="1"&gt;Steve&lt;/name&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

      <para>Hence if we capture strings on this page, then look at the
      "Strings" tab in SWeTE we would only see the first string pulled
      in:</para>

      <para>"Hello my name is &lt;span&gt;Steve&lt;/span&gt;"</para>

      <para>If we then translate this string into French using the translation
      form, e.g. using the following translation:</para>

      <para>"Bonjour mon nom est &lt;span&gt;Steve&lt;/span&gt;",</para>

      <para>Then SWeTE would translate the page as follows:</para>

      <programlisting>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;body&gt;

        &lt;ul&gt;
            &lt;li&gt;Bonjour mon nom est &lt;span&gt;Steve&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;Bonjour mon nom est &lt;a href="home.html"&gt;Steve&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;Bonjour mon nom est &lt;name data-swete-inline="1"&gt;Steve&lt;/name&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

      <para>Notice that SWeTe preserved the tags. (i.e. even though the
      translation memory only contained a translation for the &lt;span&gt; tag
      version, it presered the &lt;a&gt; and &lt;name&gt; tags properly on
      translation).</para>
    </example>

    <section>
      <title>Inline Variables (using data-swete-translate)</title>

      <para>Many web applications use server-side technologies and templates
      to generate large numbers of web pages that use the same format, but
      have different data. For example, most sites that include a login
      mechanism will have some sort of status message like:</para>

      <para>"You are logged in as Steve"</para>

      <para>By default, SWeTE will probably import all of these strings
      separately so that your translation memory will be full of strings
      like:</para>

      <para/>

      <itemizedlist>
        <listitem>
          <para>You are logged in as Steve</para>
        </listitem>

        <listitem>
          <para>You are logged in as Mary</para>
        </listitem>

        <listitem>
          <para>You are logged in as Anne</para>

          <para>etc...</para>
        </listitem>
      </itemizedlist>

      <para>This is not maintainable. It would be better if you could provide
      a translation for the string structure once, and then let SWeTE fill in
      the names afterwards. In fact, you can mark a section of a string as a
      "variable" using the data-swete-translate attribute. E.g. If you modify
      the output so that it says:</para>

      <programlisting>You are logged in as &lt;span data-swete-translate="0"&gt;Steve&lt;/span&gt;</programlisting>

      <para>Then SWeTE will be be able to store the string once, and apply it
      to all different name variations.</para>

      <para>The following strings are equivalent for SWeTE:</para>

      <itemizedlist>
        <listitem>
          <para>You are logged in as &lt;span
          data-swete-translate="0"&gt;Steve&lt;/span&gt;</para>
        </listitem>

        <listitem>
          <para>You are logged in as &lt;span
          data-swete-translate="0"&gt;Mary&lt;/span&gt;</para>
        </listitem>

        <listitem>
          <para>You are logged in as &lt;span
          data-swete-translate="0"&gt;Anne&lt;/span&gt;</para>
        </listitem>
      </itemizedlist>

      <example>
        <title>Using inline variables</title>

        <para>The following page has 3 strings, but since they are all
        equivalent unders SWeTE's string equivalence rules, it will only store
        the first one in the translation memory. The equivalence relies on the
        use of the data-swete-translate directive to mark a section as an
        inline variable.</para>

        <programlisting>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;body&gt;

        &lt;ul&gt;
            &lt;li&gt;Hello my name is &lt;span data-swete-translate="0"&gt;Steve&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;Hello my name is &lt;span data-swete-translate="0"&gt;Mary&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;Hello my name is &lt;span data-swete-translate="0"&gt;Anne&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

        <para>Hence if we capture strings on this page, then look at the
        "Strings" tab in SWeTE we would only see the first string pulled
        in:</para>

        <para>"Hello my name is &lt;span
        data-swete-translate="0"&gt;Steve&lt;/span&gt;"</para>

        <para>If we then translate this string into French using the
        translation form, e.g. using the following translation:</para>

        <para>"Bonjour mon nom est &lt;span
        data-swete-translate="0"&gt;Steve&lt;/span&gt;",</para>

        <para>Then SWeTE would translate the page as follows:</para>

        <programlisting>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;body&gt;

        &lt;ul&gt;
            &lt;li&gt;Bonjour mon nom est &lt;span data-swete-translate="0"&gt;Steve&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;Bonjour mon nom est &lt;span data-swete-translate="0"&gt;Mary&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;Bonjour mon nom est &lt;span data-swete-translate="0"&gt;Anne&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

        <para>Effective use of inline variables is critical for the effective
        internationalization of dynamic websites. It can reduce the number of
        strings that need to be translated by several orders of magnitude. It
        may be the difference between a translation being trivial and
        intractable.</para>
      </example>
    </section>

    <section>
      <title>Dealing with inline Numbers</title>

      <para>When translating strings that have a mixture of words and numbers,
      it is desirable to be able to reuse similar translations. E.g. Consider
      the strings:</para>

      <itemizedlist>
        <listitem>
          <para>I have 2 dogs and 3 cats.</para>
        </listitem>

        <listitem>
          <para>I have 4 dogs and 100 cats.</para>
        </listitem>
      </itemizedlist>

      <para>These strings are identical at a core level so it would be nice if
      we could just translate the structure of the string (i.e. "I have x dogs
      and y cats") and have the translation applied to all variations. SWeTE
      doesn't inherently factor out numbers from strings when it comes to
      equivalency. The two strings above are not actually equal in the eyes of
      the translation parser. However SWeTE makes use of a pre-processing text
      filter to wrap all numbers in span tags with the
      data-swete-translate="0" attribute so that similar strings can be
      treated as equivalent.</para>

      <para>The way this works is:</para>

      <para/>

      <orderedlist>
        <listitem>
          <para>SWeTE loads the source page from the source website.</para>
        </listitem>

        <listitem>
          <para>SWeTE performs pattern matching and replacement on the page
          content to wrap all numbers (in text nodes) with &lt;span
          data-swete-translate="0"&gt; tags.</para>
        </listitem>

        <listitem>
          <para>The translation parser parses the modified content.</para>
        </listitem>
      </orderedlist>

      <example>
        <title>Processing Page with Numbers</title>

        <para>Consider the following snippet from a web page:</para>

        <programlisting>&lt;p&gt;I have 2 dogs and 3 cats.&lt;/p&gt;
&lt;p&gt;I have 4 dogs and 100 cats.&lt;/p&gt;</programlisting>

        <para>When SWeTE first loads the snippet from the source server, it
        will apply the text filter and convert this to:</para>

        <programlisting>&lt;p&gt;I have &lt;span data-swete-translate="0"&gt;2&lt;/span&gt; dogs and\
 &lt;span data-swete-translate="0"&gt;3&lt;/span&gt; cats.&lt;/p&gt;
&lt;p&gt;I have &lt;span data-swete-translate="0"&gt;4&lt;/span&gt; dogs and\
 &lt;span data-swete-translate="0"&gt;100&lt;/span&gt; cats.&lt;/p&gt;</programlisting>

        <para/>

        <para>(Note, the content is wrapped for readability). Now all of the
        numbers have been transformed in to inline variables so that when this
        page is parsed by the translation parser, only one string will be
        extracted, since both paragraphs are now deemed to be
        equivalent.</para>
      </example>

      <tip>
        <para>Text filters can be used to do much more than just convert
        numbers into inline variables. They can be used to recognize dates,
        currency, and just about any other pattern that can be matched by a
        regular expression. SWeTE includes a set of default text filters (e.g.
        for numbers and dates) that are applied to every site automatically,
        but you can easily add your own filters as well to help pre-process
        webpage content before it is parsed by the translation parser. Read
        more about text filters in chapter ??.</para>
      </tip>
    </section>

    <section>
      <title>Dealing with Dates and Times</title>

      <para>Many applications make use of date and time in such a way that it
      is not practical to have a translator explicitly translate every
      instance. Luckily, computers can do a fine job of translating dates and
      times to different formats and languages. In order to allow computers to
      perform date translation automatically, it needs some cues from the web
      page to let it know where a date occurs, what format it is in (for
      processing purposes), and what format it should be converted to (for
      translation purposes). There are two HTML attributes that are supported
      for this purpose:</para>

      <orderedlist>
        <listitem>
          <para><literal>data-date-format </literal>: Specifies the format
          that the date is in using <ulink
          url="http://userguide.icu-project.org/formatparse/datetime">ICU date
          format notation</ulink>.</para>
        </listitem>

        <listitem>
          <para><literal>data-date-format-target</literal> : Specifies the
          format that the date should be converted to in <ulink
          url="http://userguide.icu-project.org/formatparse/datetime">ICU date
          format notation</ulink>. If this is omitted, then the format
          specified by the data-date-format attribute is used.</para>
        </listitem>
      </orderedlist>

      <para>SWeTE includes a small selection of text filters to automatically
      wrap any detected dates in <literal>&lt;span
      data-date-format&gt;</literal> tags so that the translation processor
      will correctly translate the dates.</para>

      <note>
        <para>You must set the source date locale and target date locale
        settings for the site in order for date translation to work properly.
        You also need to have the <ulink
        url="http://php.net/manual/en/book.intl.php">PHP intl
        extension</ulink> installed. It is included with PHP by default since
        5.3, but it still needs to be set in the configure flags when building
        PHP for it to be included.</para>
      </note>

      <warning>
        <para>Setting the source and target date locales currently depends on
        way of obtaining the available locales in the system which may not be
        available on Windows servers. As of 0.2.3, this has not been tested on
        Windows servers so there is a good chance it may not work.</para>
      </warning>

      <para>The built-in date text filters only recognize a few common date
      formats. It is a good idea to modify these text filters, or create your
      own filters to cater to the date formats that are used in your
      application.</para>

      <example>
        <title>Example Date Conversions</title>

        <para>The following snippet shows how the data-date-format tags
        work.</para>

        <programlisting>&lt;p&gt;Today's date is 
    &lt;span data-date-format="MMMM d, y"&gt;
        September 9, 2008
    &lt;/span&gt;
&lt;/p&gt;</programlisting>

        <para>In this case the <literal>data-date-format</literal> tag is set
        to "MMMM d, y" which is <ulink
        url="http://userguide.icu-project.org/formatparse/datetime">ICU date
        format</ulink> for "&lt;full month name&gt; &lt;day of month&gt;, 4
        digit year". The output after SWeTE parses this snippet (assuming the
        source date format of the site is set to <literal>en_CA</literal> and
        the target date format is <literal>fr_CA</literal>) would be:</para>

        <programlisting>&lt;p&gt;Today's date is 
    &lt;span data-swete-translate="0" data-date-format="MMMM d, y"&gt;
        septembre 9, 2008
    &lt;/span&gt;
&lt;/p&gt;para</programlisting>

        <para>Note, that the format specified in
        <literal>data-date-format</literal> must match exactly the format of
        the date string provided inside the tag or parsing will fail and the
        date will not be converted. Also notice that the
        data-swete-translate="0" attribute is automatically added to this tag
        to convert it to an inline variable. That way we can translate the
        string "Today's date is xxx" once in the translation memory and have
        it apply to all possible dates.</para>

        <para>There is still a problem with this date conversion. "septembre
        9, 2008" is not the normal way that a date is formatted in French. The
        month name has been translated, but French native speakers would
        expect the date in the form "9 septembre 2008". Hence we need to
        specify a different output format string than for input format. We'll
        add the <literal>data-date-format-target</literal> attribute as
        follows:</para>

        <programlisting>&lt;p&gt;Today's date is 
    &lt;span data-date-format="MMMM d, y"
          data-date-format-target="d MMMM y"&gt;
        September 9, 2008
    &lt;/span&gt;
&lt;/p&gt;</programlisting>

        <para>And the output would become:</para>

        <programlisting>&lt;p&gt;Today's date is 
    &lt;span data-date-format="MMMM d, y" 
          data-date-format-target="d MMMM y" 
          data-swete-translate="0"&gt;
        9 septembre 2008
    &lt;/span&gt;
&lt;/p&gt;</programlisting>
      </example>

      <section>
        <title>Enabling Date Conversion</title>

        <para>Date conversion, in SWeTE, requires the PHP Intl extension to be
        installed. And even if it is installed date conversion will not happen
        automatically until you configure the source date locale and target
        date locale for the site. You can set these properties either during
        the creation of a new site or after creation using the site's Edit
        form.</para>

        <para>Configure the date locales for an existing site as
        follows:</para>

        <orderedlist>
          <listitem>
            <para>Log into the SWeTE administration panel. (i.e.
            http://example.com/path-to-swete/swete-admin/index.php)</para>
          </listitem>

          <listitem>
            <para>Click on the "Dashboard" link in the upper right.</para>
          </listitem>

          <listitem>
            <para>Inside the "Websites" portlet, click on the "Menu" icon to
            the right of your site.</para>

            <para><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/ch01.menu-icon.png"/>
                </imageobject>
              </inlinemediaobject></para>
          </listitem>

          <listitem>
            <para>Select "Edit" in the contextual menu.</para>

            <para><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/ch02.site-menu.png"/>
                </imageobject>
              </inlinemediaobject></para>
          </listitem>

          <listitem>
            <para>On the edit form, click the "More Details..." subheading at
            the bottom of the form to reveal the advanced options. This will
            reveal two select lists that will allow you to select the locales
            to use for parsing and formatting dates.</para>

            <para><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/ch02.date_locale_fields.png"/>
                </imageobject>
              </inlinemediaobject></para>
          </listitem>

          <listitem>
            <para>Click "Save"</para>
          </listitem>
        </orderedlist>

        <para>At this point, SWeTE should properly convert dates that have
        been marked with the <literal>data-date-format</literal> and
        <literal>data-date-format-target</literal> attributes.</para>
      </section>

      <section>
        <title>Automatic Date Wrapping</title>

        <para>Wrapping dates explicitly in your source HTML may be cumbersome,
        or not even possible if you don't have access to change the source
        HTML. A better way to handle dates is to implement text filters to
        automatically wrap all dates in the appropriate tags prior to
        translation.</para>

        <para>Text filters are regular expressions that are applied to the
        source HTML in the preprocessing step (i.e. before SWeTE parses the
        page for translation). SWeTE comes with a small set of default text
        filters that wrap such things as numbers, month names, days of week,
        and a small set of date formats. It is recommended that you take stock
        of the date formats that appear in your site, and set up explicit text
        filters for those formats.</para>

        <para/>

        <section>
          <title>Browsing a Site's Text Filters</title>

          <para>You can see your site's text filters by:</para>

          <orderedlist>
            <listitem>
              <para>Clicking on "Sites" in the top menu bar.</para>
            </listitem>

            <listitem>
              <para>Click on your site in the list to access the site
              details.</para>
            </listitem>

            <listitem>
              <para>Click on the "Text Filters" sub-tab under your site's
              details.</para>

              <para><inlinemediaobject>
                  <imageobject>
                    <imagedata contentwidth="50%"
                               fileref="images/ch02.text-filters.png"/>
                  </imageobject>
                </inlinemediaobject></para>
            </listitem>
          </orderedlist>

          <para>You'll notice a list of default text filters that are applied
          to every page before it is parsed. Most of these filters have to do
          with date in some capacity. The filter_order column specifies the
          order in which a filter is applied. Generally we want the most
          specific filters to be applied first. E.g. We would want filters
          that recognize a full date like "September 2, 2002" to be applied
          before a filter for month names or numbers, because if the month is
          converted first, it would change the date to a form that the date
          filter wouldn't recognize.</para>
        </section>

        <section>
          <title>Anatomy of a Filter</title>

          <para>Click on the "English Dates with Full Month Names" filter to
          see how this filter is set up.</para>

          <para><inlinemediaobject>
              <imageobject>
                <imagedata contentwidth="70%"
                           fileref="images/ch02.filter-details.png"/>
              </imageobject>
            </inlinemediaobject></para>

          <para>The key to this lies in the "Pattern" and "Replacement" field.
          The pattern is a <ulink
          url="http://php.net/manual/en/book.pcre.php">PERL compatible regular
          expression</ulink>. Notice that it begins and ends in a '/'
          character. In this case it is set up to explicitly look for dates of
          the form "MonthName day, year". The replacement field is the text
          that matching strings should be replaced with. Just like PHP's
          preg_replace() function, this accepts callback variables to include
          portions of the original string in the output.</para>

          <para>You'll notice that this particular pattern would convert
          strings like:</para>

          <para>September 9, 2008</para>

          <para>to</para>

          <para>&lt;span data-swete-translate="0" data-date-format="MMMM
          d,y"&gt;September 9, 2008&lt;/span&gt;</para>

          <para>Hence, with this filter activated in the site (which it is by
          default) all dates of this form will automatically be converted to
          the target language's equivalent.</para>
        </section>
      </section>
    </section>
  </section>

  <section>
    <title>Summary</title>

    <para>In this chapter, we discussed the SWeTE translation parser and
    showed how it can be manipulated to partition content in the ways of our
    choosing. We also discussed string equivalence and introduced some
    strategies for minimizing the number of unique strings that are required
    to be held by our translation memories (e.g. using inline variables and
    automatic date formatting).</para>

    <para>Using a combination of source content design (i.e. adding SWeTE meta
    tags directly into your source content), preprocessing, and
    post-processing it should be possible to efficiently manage the
    internationalization and translation of the most complex web
    application.</para>
  </section>
</chapter>
